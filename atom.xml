<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>外大武的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lixueon.com/"/>
  <updated>2020-05-31T08:34:46.330Z</updated>
  <id>http://lixueon.com/</id>
  
  <author>
    <name>外大武</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>诗经.周南.关雎</title>
    <link href="http://lixueon.com/2020/05/31/ShiJing-GuanJu/"/>
    <id>http://lixueon.com/2020/05/31/ShiJing-GuanJu/</id>
    <published>2020-05-31T04:32:23.571Z</published>
    <updated>2020-05-31T08:34:46.330Z</updated>
    
    <content type="html"><![CDATA[<p>关雎是诗经的第一篇，解读很多，个人愿相信它在描写男女思恋，而非女德。 <a id="more"></a></p><h3 id="关雎">关雎</h3><p>关关雎鸠，在河之洲，窈窕淑女，君子好逑。 参差荇菜，左右流之，窈窕淑女，寤寐求之， 求之不得，寤寐思服，悠哉悠哉，辗转反侧。 参差荇菜，左右采之，窈窕淑女，琴瑟友之。 参差荇菜，左右芼之，窈窕淑女，钟鼓乐之。</p><h4 id="注解">注解</h4><ul><li>关关 - 象声词，雌雄二鸟相互应和的叫声</li><li>雎 (j<span class="math inline">\(\bar{u}\)</span>) 鸠 (ji<span class="math inline">\(\bar{u}\)</span>) - 一种水鸟，传说它们雌雄形影不离</li><li>窈 - 深邃，喻女子心灵美</li><li>窕 - 幽美，喻女子仪表美</li><li>淑 - 好，善良</li><li>君子 - 指人格高尚、道德品行兼好之人</li><li>荇 (x<span class="math inline">\(\grave{i}\)</span>ng) 菜 - 一种可食的水草</li><li>思服 - 思念</li><li>流、采、芼 (m<span class="math inline">\(\grave{a}\)</span>o) - 摘取</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关雎是诗经的第一篇，解读很多，个人愿相信它在描写男女思恋，而非女德。
    
    </summary>
    
      <category term="reading" scheme="http://lixueon.com/categories/reading/"/>
    
    
      <category term="literature" scheme="http://lixueon.com/tags/literature/"/>
    
  </entry>
  
  <entry>
    <title>基金005644</title>
    <link href="http://lixueon.com/2019/02/27/Fund-005644-2018/"/>
    <id>http://lixueon.com/2019/02/27/Fund-005644-2018/</id>
    <published>2019-02-27T09:07:33.499Z</published>
    <updated>2019-02-27T13:59:24.566Z</updated>
    
    <content type="html"><![CDATA[<p>本文研究基金 “广发沪港深龙头混合 (005644)” 在2018年净值减少的原因。 <a id="more"></a></p><p>2018年初，看着基金名字”沪港深龙头“就买入了基金005644，然后就悲剧了，基金从2018年 3月21日开始交易后，净值一路走低，截至到四季度时亏15%，它成为2018年最失败的投资。</p><p>此此基金可同时交易深沪港的股票，研究后却发现此基金只交易港股，并未买卖深沪的股票， 所以深沪股市大涨，此基金却依旧巨亏，尤其麻烦的是基金经理貌似缺乏投资港股的经验， 一味追涨杀跌，搞不懂基金经理为啥不是价值投资？这操作同散户没任何区别，咋盈利？</p><p>根据基金的<a href="http://fundf10.eastmoney.com/ccmx_005644.html" target="_blank" rel="noopener">持仓信息</a>，制作下表模拟基金的行为：</p><div><p><img src="/images/fund-005644-2018.PNG" alt="005644持仓分析"></p></div><p>其中:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">季度均价 = (当季度内最高收盘价 + 当季度内最低收盘价) / 2</span><br></pre></td></tr></table></figure><p>无法通过持仓而准确知道买入和卖出股票的价格和数量，但它可充分反映投资过程，由于 二季度末时股票资金总额约250亿元，截至到2018年末亏损总额为约36.4亿元，因此：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">盈余率 = 1 - （36.4/250） = 0.856</span><br></pre></td></tr></table></figure><p>这个结果匹配2018年末的基金净值0.8439，所以净值减少的原因就是炒股亏了。</p><p>总之，失败不总是坏事，至少得到如下经验：</p><ul><li>买基金前，必须要先仔细看说明，关注基金经理过往战绩，不要找小白，专业的事情 要交给专业并优秀的人去做，找那些赚佣金的同时兼顾客户利益的基金经理。</li><li>购买基金时，必须分批投入，风险至上，及时止损。</li><li>购买基金后，不要幻想坐等收钱，必须定时跟踪基金状态，买龙头股也不一定会盈利， 即使专业的人去操作也不一定。</li><li>股票投资要严守纪律，严格止损。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文研究基金 “广发沪港深龙头混合 (005644)” 在2018年净值减少的原因。
    
    </summary>
    
      <category term="stocks" scheme="http://lixueon.com/categories/stocks/"/>
    
    
      <category term="finance" scheme="http://lixueon.com/tags/finance/"/>
    
  </entry>
  
  <entry>
    <title>单件 (SINGLETON)</title>
    <link href="http://lixueon.com/2018/08/29/DesignPattern-Singleton/"/>
    <id>http://lixueon.com/2018/08/29/DesignPattern-Singleton/</id>
    <published>2018-08-29T11:40:18.354Z</published>
    <updated>2018-09-01T14:57:07.701Z</updated>
    
    <content type="html"><![CDATA[<p>单件模式是一个简单的模式，要正确的实现此模式仍需要考虑很多细节，由于单件模式不符合对象 的单一职责原则，论坛上对是否应该使用单件模式的争议很多，因单件模式适用的场景很少，在 程序设计中又极容易被滥用，如果没有急迫并且有意义的需要时，应该避免使用这个模式。</p><a id="more"></a><h2 id="目的">目的</h2><ul><li>确保一个类只有一个实例 (Ensure a class only has one instance)</li><li>提供一个全局访问点 (Provide a global point of access to it)</li></ul><h2 id="动机">动机</h2><p>有一些对象可能只需要一个，例如：线程池(thread pool), 缓存(cache), 注册表对象，日志 对象，打印机驱动程序对象，窗口管理器等。</p><p>如何可以保证一个类只有一个实例？全局变量可以被访问，但不能防止被实例化多次。一个办法是 让类自身保存它的唯一实例，这个类提供一个访问该实例的方法，即单件模式。</p><p>单件模式提供了全局访问点，同全局变量一样方便，但避免了全局变量的缺点。比如，将对象赋值 给全局变量，通常在程序开始时创建对象（JVM是用到时创建），如果此对象非常耗费资源，而程序 中没有使用到它，则形成浪费。通过使用单件，可以在需要时创建这个对象。</p><h2 id="参与者-participants">参与者 (Participants)</h2><ul><li><p>Singleton</p><ul><li>定义Instance方法，允许客户访问它的唯一实例。</li><li>负责创建它自己的唯一实例</li></ul></li></ul><h2 id="协作-collaborations">协作 (Collaborations)</h2><ul><li>客户只能通过Singleton的Instance方法访问Singleton的实例。</li></ul><h2 id="效果">效果</h2><h3 id="好处">好处</h3><ul><li>跨平台：使用合适的中间件（例如：RMI），可以把单件模式扩展为跨多个JVM或多个计算机工作。</li><li>适用于任何类：将类的构造函数变为私有的，然后增加相应的静态函数和变量，就可实现单件。</li><li>可以透过派生创建：给定一个类，可以创建它的一个单件子类</li><li>延迟求值（Lazy evaluation）：如果单件从未使用，就绝不创建它。</li></ul><h3 id="代价">代价</h3><ul><li>摧毁方法未定义：没有好的方法去destroy一个单件或解除其职责。此问题在C++中尤其严重。</li><li>不能继承：从单件类继承的子类并不是单件，需要添加静态函数和变量从而变成单件。</li><li>效率问题：当未使用静态函数的静态变量，每次调用Instance方法都会执行一个if语句。</li><li>不透明性：单件的使用者知道在调用单件模式，因为需要调用Instance方法。</li></ul><h2 id="实现">实现</h2><h3 id="c的相关问题">C++的相关问题</h3><ul><li><p>是否支持延迟求值可依照具体情况而定</p></li><li><p>考虑默认拷贝构造函数</p></li><li><p>私有化构造函数，确保只通过Instance方法得到实例</p></li><li><p>线程安全 由于C++ 2011已经支持线程安全，参考下面的实例代码。 对于C++ 2003及之前版本，线程安全可采用如下方式：</p><ul><li>在Instance方法中增加同步锁</li><li>在Instance方法中使用Double-Checked Locking</li><li>使用类的静态变量</li></ul></li></ul><h3 id="java的相关问题">Java的相关问题</h3><ul><li>Java中实现单件模式需要私有的构造器，一个静态方法，一个静态变量</li><li>确定性能和资源上的限制，然后小心选择适当的方案，以解决多线程问题（最好认定所有程序 都是多线程的）</li><li>只有Java 5或以上版本,才支持双重检查锁 (Double-Checked Locking)</li><li>小心，如果你使用多个类加载器，可能导致单件失效而产生多个实例</li><li>如果使用JVM 1.2或之前版本，你必须建立单件注册表，以免垃圾回收期将单件回收</li></ul><h2 id="代码">代码</h2><h3 id="c-2003-单线程版本">C++ 2003 单线程版本</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">Instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton() &#123;&#125;</span><br><span class="line">    Singleton(Singleton <span class="keyword">const</span>&amp;);</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(Singleton <span class="keyword">const</span>&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="c-2011-线程安全版本">C++ 2011 线程安全版本</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">Instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    Singleton(Singleton <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(Singleton <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="java静态实例化">Java静态实例化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title">Instance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _instance; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java延迟实例化---单线程">Java延迟实例化 - 单线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton _instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title">Instance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="keyword">null</span>)</span><br><span class="line">           _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> _instance; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java延迟实例化---多线程">Java延迟实例化 - 多线程</h3><p>多线程同步的问题:</p><ul><li>增加synchronized同步后，不会有两个线程同时进入方法，同步会令执行效率下降100倍。</li><li>只有第一次执行此方法时需要同步，对象创建后，同步成为一个影响性能的累赘。</li><li>如果资源创建和运行方面的负担不繁重，可考虑“静态实例化”来替代同步。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton _instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">Instance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="keyword">null</span>)</span><br><span class="line">           _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> _instance; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java双重检查锁double-checked-locking---多线程">Java双重检查锁(Double-Checked Locking) - 多线程</h3><p>《设计模式精解》指出：Java中双重检查锁无效果，理由如下：</p><ul><li>Java内存管理指出，只在两个线程在同一个对象上进行同步时，它才会保证一个线程 B 能够 看到另一个线程 A 的改变，从而使得线程 A 得 synchronized 块对线程 B 变为原子，即 要么什么都不做，要么完全改好。</li><li>Java并不是一种按照源代码顺序执行的语言。Java对编译器和虚拟机的要求时满足 as-if-serial: 也就是只要它能够达到和严格顺序执行一样的效果，指令执行的顺序可以随便安排。</li></ul><p>《Head First设计模式》指出：Java 5或之后版本可通过 volatile 支持双重检查锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton _instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title">Instance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> （_instance == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> （_instance == <span class="keyword">null</span>)</span><br><span class="line">                    _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _instance; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java接口应用示例">Java接口应用示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDatabase</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Write</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDatabase</span> <span class="keyword">implements</span> <span class="title">IDatabase</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> UserDatabase _instance = <span class="keyword">new</span> UserDatabase();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UserDatabase</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> UserDatabase <span class="title">Instance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _instance; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Some Implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="c注册表应用示例">C++注册表应用示例</h3><ul><li>Singleton.h</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDatabase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> :</span> <span class="keyword">public</span> IDatabase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Singleton() &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Singleton(Singleton <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>= (Singleton <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">Instance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Register</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, Singleton* instance)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">Lookup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* _instance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Singleton.cpp</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, Singleton*&gt; _registry;</span><br><span class="line">Singleton* Singleton::_instance;</span><br><span class="line">Singleton* Singleton::Instance()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_instance)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* name = getenv(<span class="string">"SINGLETON"</span>);</span><br><span class="line">        _instance = Lookup(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Singleton::Register(<span class="keyword">const</span> <span class="keyword">char</span>* name, Singleton* instance)</span><br><span class="line">&#123;</span><br><span class="line">    _registry.insert(<span class="built_in">std</span>::make_pair(name, instance));</span><br><span class="line">&#125;</span><br><span class="line">Singleton* Singleton::Lookup(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _registry[name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MySingleton.h</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySingleton</span> :</span> <span class="keyword">public</span> Singleton</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MySingleton() &#123; Singleton::Register(<span class="string">"MySingleton"</span>, <span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Some Implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>client.cpp</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> MySingleton theSingleton;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _putenv(<span class="string">"SINGLETON=MySingleton"</span>);</span><br><span class="line">    Singleton::Instance()-&gt;Write();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="c工厂应用示例">C++工厂应用示例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MazeFactory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> MazeFactory* <span class="title">Instance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    MazeFactory() &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> MazeFactory* _instance;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BombedMazeFactory</span> :</span> <span class="keyword">public</span> MazeFactory</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnchantedMazeFactory</span> :</span> <span class="keyword">public</span> MazeFactory</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line">MazeFactory* MazeFactory::Instance()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_instance == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* mazeStyle = getenv(<span class="string">"MAZESTYLE"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(mazeStyle, <span class="string">"bombed"</span>) == <span class="number">0</span>) </span><br><span class="line">            _instance = <span class="keyword">new</span> BombedMazeFactory();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(mazeStyle, <span class="string">"enchanted"</span>) == <span class="number">0</span>) </span><br><span class="line">            _instance = <span class="keyword">new</span> EnchantedMazeFactory();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            _instance = <span class="keyword">new</span> MazeFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关模式-related-patterns">相关模式 (Related Patterns)</h2><p>如下模式或可用Singleton模式实现：</p><ul><li>Abstract Factory</li><li>Builder</li><li>Prototype</li></ul><h2 id="参考-reference">参考 (Reference)</h2><ul><li><a href="https://book.douban.com/subject/1052241/" target="_blank" rel="noopener">设计模式：可复用面向对象软件的基础</a></li><li><a href="https://book.douban.com/subject/1219912/" target="_blank" rel="noopener">设计模式精解</a></li><li><a href="https://book.douban.com/subject/1140457/" target="_blank" rel="noopener">敏捷软件开发</a></li><li><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener">Head First 设计模式</a></li><li><a href="https://book.douban.com/subject/1099305/" target="_blank" rel="noopener">Design Patterns</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单件模式是一个简单的模式，要正确的实现此模式仍需要考虑很多细节，由于单件模式不符合对象 的单一职责原则，论坛上对是否应该使用单件模式的争议很多，因单件模式适用的场景很少，在 程序设计中又极容易被滥用，如果没有急迫并且有意义的需要时，应该避免使用这个模式。&lt;/p&gt;
    
    </summary>
    
      <category term="软件工程" scheme="http://lixueon.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="设计模式" scheme="http://lixueon.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python 代码规范</title>
    <link href="http://lixueon.com/2018/07/04/PythonStyleGuide/"/>
    <id>http://lixueon.com/2018/07/04/PythonStyleGuide/</id>
    <published>2018-07-04T13:57:41.610Z</published>
    <updated>2018-07-04T15:44:12.436Z</updated>
    
    <content type="html"><![CDATA[<p>本文有关于Python的编码规范，以确立统一代码风格和样式，方便阅读和维护。 <a id="more"></a></p><h2 id="代码格式">代码格式</h2><h3 id="缩进">缩进</h3><p>统一使用4个空格进行缩进</p><h3 id="行宽">行宽</h3><p>每行代码尽量不超过 80 个字符(在特殊情况下可以略微超过 80 ，但最长不得超过 120) 理由： - 这在查看 side-by-side 的 diff 时很有帮助 - 方便在控制台下查看代码 - 太长可能是设计有缺陷</p><h3 id="引号">引号</h3><p>简单说，自然语言使用双引号，机器标示使用单引号，因此代码里多数应该使用 单引号 - 自然语言 使用双引号 "..." 例如错误信息；很多情况还是 unicode，使用u"你好世界" - 机器标识 使用单引号 '...' 例如 dict 里的 key - 正则表达式 使用原生的双引号 r"..." 文档字符串 (docstring) 使用三个双引号 """......"""</p><h3 id="空行">空行</h3><ul><li><p>模块级函数和类定义之间空两行；</p></li><li><p>类成员函数之间空一行； <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A:</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def hello(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p></li><li><p>可以使用多个空行分隔多组相关的函数</p></li><li><p>函数中可以使用空行分隔出逻辑相关的代码</p></li></ul><h3 id="编码">编码</h3><ul><li>如无特殊情况, 文件一律使用 UTF-8 编码</li><li>如无特殊情况, 文件头部必须加入#-<em>-coding:utf-8-</em>-标识</li></ul><h3 id="import语句">import语句</h3><ul><li><p>import 语句应该分行书写 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 正确的写法</span><br><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"># 不推荐的写法</span><br><span class="line">import sys,os</span><br><span class="line"></span><br><span class="line"># 正确的写法</span><br><span class="line">from subprocess import Popen, PIPE</span><br></pre></td></tr></table></figure></p></li><li><p>import语句应该使用 absolute import <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 正确的写法</span><br><span class="line">from foo.bar import Bar</span><br><span class="line"></span><br><span class="line"># 不推荐的写法</span><br><span class="line">from ..bar import Bar</span><br></pre></td></tr></table></figure></p></li><li><p>import语句应该放在文件头部，置于模块说明及docstring之后，于全局变量之前；</p></li><li><p>import语句应该按照顺序排列，每组之间用一个空行分隔 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">import msgpack</span><br><span class="line">import zmq</span><br><span class="line"></span><br><span class="line">import foo</span><br></pre></td></tr></table></figure></p></li><li><p>导入其他模块的类定义时，可以使用相对导入 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from myclass import MyClass</span><br></pre></td></tr></table></figure></p></li><li><p>如果发生命名冲突，则可使用命名空间 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import bar</span><br><span class="line">import foo.bar</span><br><span class="line"></span><br><span class="line">bar.Bar()</span><br><span class="line">foo.bar.Bar()</span><br></pre></td></tr></table></figure></p></li></ul><h3 id="空格">空格</h3><ul><li><p>在二元运算符两边各空一格[=,-,+=,==,&gt;,in,is not, and]: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 正确的写法</span><br><span class="line">i = i + 1</span><br><span class="line">submitted += 1</span><br><span class="line">x = x * 2 - 1</span><br><span class="line">hypot2 = x * x + y * y</span><br><span class="line">c = (a + b) * (a - b)</span><br><span class="line"></span><br><span class="line"># 不推荐的写法</span><br><span class="line">i=i+1</span><br><span class="line">submitted +=1</span><br><span class="line">x = x*2 - 1</span><br><span class="line">hypot2 = x*x + y*y</span><br><span class="line">c = (a+b) * (a-b)</span><br></pre></td></tr></table></figure></p></li><li><p>函数的参数列表中，,之后要有空格 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 正确的写法</span><br><span class="line">def complex(real, imag):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"># 不推荐的写法</span><br><span class="line">def complex(real,imag):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p></li><li><p>函数的参数列表中，默认值等号两边不要添加空格 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 正确的写法</span><br><span class="line">def complex(real, imag=0.0):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"># 不推荐的写法</span><br><span class="line">def complex(real, imag = 0.0):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p></li><li><p>左括号之后，右括号之前不要加多余的空格 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 正确的写法</span><br><span class="line">spam(ham[1], &#123;eggs: 2&#125;)</span><br><span class="line"></span><br><span class="line"># 不推荐的写法</span><br><span class="line">spam( ham[1], &#123; eggs : 2 &#125; )</span><br></pre></td></tr></table></figure></p></li><li><p>字典对象的左括号之前不要多余的空格 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 正确的写法</span><br><span class="line">dict[&apos;key&apos;] = list[index]</span><br><span class="line"></span><br><span class="line"># 不推荐的写法</span><br><span class="line">dict [&apos;key&apos;] = list [index]</span><br></pre></td></tr></table></figure></p></li><li><p>不要为对齐赋值语句而使用的额外空格 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 正确的写法</span><br><span class="line">x = 1</span><br><span class="line">y = 2</span><br><span class="line">long_variable = 3</span><br><span class="line"></span><br><span class="line"># 不推荐的写法</span><br><span class="line">x             = 1</span><br><span class="line">y             = 2</span><br><span class="line">long_variable = 3</span><br></pre></td></tr></table></figure></p></li></ul><h3 id="换行">换行</h3><p>Python 支持括号内的换行。这时有两种情况。</p><ul><li><p>第二行缩进到括号的起始处 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo = long_function_name(var_one, var_two,</span><br><span class="line">                         var_three, var_four)</span><br></pre></td></tr></table></figure></p></li><li><p>第二行缩进 4 个空格，适用于起始括号就换行的情形 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def long_function_name(</span><br><span class="line">        var_one, var_two, var_three,</span><br><span class="line">        var_four):</span><br><span class="line">    print(var_one)</span><br></pre></td></tr></table></figure></p></li><li><p>使用反斜杠，二元运算符+ .等应出现在行末；长字符串也可以用此法换行 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">session.query(MyTable).\</span><br><span class="line">        filter_by(id=1).\</span><br><span class="line">        one()</span><br><span class="line"></span><br><span class="line">print &apos;Hello, &apos;\</span><br><span class="line">      &apos;%s %s!&apos; %\</span><br><span class="line">      (&apos;Harry&apos;, &apos;Potter&apos;)</span><br></pre></td></tr></table></figure></p></li><li><p>禁止复合语句，即一行中包含多个语句： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 正确的写法</span><br><span class="line">do_first()</span><br><span class="line">do_second()</span><br><span class="line">do_third()</span><br><span class="line"></span><br><span class="line"># 不推荐的写法</span><br><span class="line">do_first();do_second();do_third();</span><br></pre></td></tr></table></figure></p></li><li><p>if/for/while一定要换行： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 正确的写法</span><br><span class="line">if foo == &apos;blah&apos;:</span><br><span class="line">    do_blah_thing()</span><br><span class="line"></span><br><span class="line"># 不推荐的写法</span><br><span class="line">if foo == &apos;blah&apos;: do_blash_thing()</span><br></pre></td></tr></table></figure></p></li></ul><h3 id="docstring">docstring</h3><p>docstring 的规范中最其本的两点：</p><ul><li>所有的公共模块、函数、类、方法，都应该写 docstring 。私有方法不一定需要，但应该在 def 后提供一个块注释来说明。</li><li>docstring 的结束"""应该独占一行，除非此 docstring 只有一行。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;Return a foobar</span><br><span class="line">Optional plotz says to frobnicate the bizbaz first.</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;Oneline docstring&quot;&quot;&quot;</span><br></pre></td></tr></table></figure></li></ul><h2 id="注释">注释</h2><h3 id="块注释">块注释</h3><ul><li>“#”号后空一格，段落件用空行分开（同样需要“#”号） <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 块注释</span><br><span class="line"># 块注释</span><br><span class="line">#</span><br><span class="line"># 块注释</span><br><span class="line"># 块注释</span><br></pre></td></tr></table></figure></li></ul><h3 id="行注释">行注释</h3><ul><li>至少使用两个空格和语句分开，注意不要使用无意义的注释 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 正确的写法</span><br><span class="line">x = x + 1  # 边框加粗一个像素</span><br><span class="line"></span><br><span class="line"># 不推荐的写法(无意义的注释)</span><br><span class="line">x = x + 1 # x加1</span><br></pre></td></tr></table></figure></li></ul><h3 id="建议">建议</h3><ul><li>在代码的关键部分(或比较复杂的地方), 能写注释的要尽量写注释</li><li>比较重要的注释段, 使用多个等号隔开, 可以更加醒目, 突出重要性 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app = create_app(name, options)</span><br><span class="line"></span><br><span class="line"># =====================================</span><br><span class="line"># 请勿在此处添加 get post等app路由行为 !!!</span><br><span class="line"># =====================================</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure></li></ul><h3 id="文档注释docstring">文档注释（Docstring）</h3><p>作为文档的Docstring一般出现在模块头部、函数和类的头部，这样在python中可以通过对象的__doc__对象获取文档. 编辑器和IDE也可以根据Docstring给出自动提示. 文档注释以 """ 开头和结尾, 首行不换行, 如多行末行必换行.</p><ul><li><p>以下是Google的docstring风格示例 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;Example docstrings.</span><br><span class="line"></span><br><span class="line">This module demonstrates documentation as specified by the `Google Python</span><br><span class="line">Style Guide`_. Docstrings may extend over multiple lines. Sections are created</span><br><span class="line">with a section header and a colon followed by a block of indented text.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">    Examples can be given using either the ``Example`` or ``Examples``</span><br><span class="line">    sections. Sections support any reStructuredText formatting, including</span><br><span class="line">    literal blocks::</span><br><span class="line"></span><br><span class="line">        $ python example_google.py</span><br><span class="line"></span><br><span class="line">Section breaks are created by resuming unindented text. Section breaks</span><br><span class="line">are also implicitly created anytime a new section starts.</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure></p></li><li><p>不要在文档注释复制函数定义原型, 而是具体描述其具体内容, 解释具体参数和返回值等 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#  正确的写法</span><br><span class="line">def function(a, b):</span><br><span class="line">    &quot;&quot;&quot;计算并返回a到b范围内数据的平均值&quot;&quot;&quot;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">#  不推荐的写法(不要写函数原型等废话)</span><br><span class="line">def function(a, b):</span><br><span class="line">    &quot;&quot;&quot;function(a, b) -&gt; list&quot;&quot;&quot;</span><br><span class="line">    ... ...</span><br></pre></td></tr></table></figure></p></li><li><p>对函数参数、返回值等的说明采用numpy标准, 如下所示 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def func(arg1, arg2):</span><br><span class="line">    &quot;&quot;&quot;在这里写函数的一句话总结(如: 计算平均值).</span><br><span class="line"></span><br><span class="line">    这里是具体描述.</span><br><span class="line"></span><br><span class="line">    参数</span><br><span class="line">    ----------</span><br><span class="line">    arg1 : int</span><br><span class="line">        arg1的具体描述</span><br><span class="line">    arg2 : int</span><br><span class="line">        arg2的具体描述</span><br><span class="line"></span><br><span class="line">    返回值</span><br><span class="line">    -------</span><br><span class="line">    int</span><br><span class="line">        返回值的具体描述</span><br><span class="line"></span><br><span class="line">    参看</span><br><span class="line">    --------</span><br><span class="line">    otherfunc : 其它关联函数等...</span><br><span class="line"></span><br><span class="line">    示例</span><br><span class="line">    --------</span><br><span class="line">    示例使用doctest格式, 在`&gt;&gt;&gt;`后的代码可以被文档测试工具作为测试用例自动运行</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; a=[1,2,3]</span><br><span class="line">    &gt;&gt;&gt; print [x + 3 for x in a]</span><br><span class="line">    [4, 5, 6]</span><br><span class="line">    &quot;&quot;&quot;</span><br></pre></td></tr></table></figure></p></li><li><p>文档注释不限于中英文, 但不要中英文混用</p></li><li><p>文档注释不是越长越好, 通常一两句话能把情况说清楚即可</p></li><li><p>模块、公有类、公有方法, 能写文档注释的, 应该尽量写文档注释</p></li></ul><h2 id="命名规范">命名规范</h2><h3 id="模块">模块</h3><ul><li>模块尽量使用小写命名，首字母保持小写，尽量不要用下划线 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 正确的模块名</span><br><span class="line">import decoder</span><br><span class="line">import html_parser</span><br><span class="line"></span><br><span class="line"># 不推荐的模块名</span><br><span class="line">import Decoder</span><br></pre></td></tr></table></figure></li></ul><h3 id="类名">类名</h3><ul><li><p>类名使用驼峰(CamelCase)命名风格，首字母大写，私有类可用一个下划线开头 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Farm():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class AnimalFarm(Farm):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class _PrivateFarm(Farm):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p></li><li><p>将相关的类和顶级函数放在同一个模块里. 不像Java, 没必要限制一个类一个模块.</p></li></ul><h3 id="函数">函数</h3><ul><li><p>函数名一律小写，如有多个单词，用下划线隔开 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def run():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def run_with_env():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p></li><li><p>私有函数在函数前加一个下划线_ <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person():</span><br><span class="line"></span><br><span class="line">    def _private_func():</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure></p></li></ul><h3 id="变量名">变量名</h3><ul><li>变量名尽量小写, 如有多个单词，用下划线隔开 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    count = 0</span><br><span class="line">    school_name = &apos;&apos;</span><br></pre></td></tr></table></figure></li></ul><h3 id="常量">常量</h3><ul><li>常量采用全大写，如有多个单词，使用下划线隔开 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MAX_CLIENT = 100</span><br><span class="line">MAX_CONNECTION = 1000</span><br><span class="line">CONNECTION_TIMEOUT = 600</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文有关于Python的编码规范，以确立统一代码风格和样式，方便阅读和维护。
    
    </summary>
    
      <category term="document" scheme="http://lixueon.com/categories/document/"/>
    
    
      <category term="python" scheme="http://lixueon.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 - 用生活常识就能看懂财务报表</title>
    <link href="http://lixueon.com/2018/04/22/%E7%94%A8%E7%94%9F%E6%B4%BB%E5%B8%B8%E8%AF%86%E5%B0%B1%E8%83%BD%E7%9C%8B%E6%87%82%E8%B4%A2%E5%8A%A1%E6%8A%A5%E8%A1%A8/"/>
    <id>http://lixueon.com/2018/04/22/用生活常识就能看懂财务报表/</id>
    <published>2018-04-22T09:48:36.386Z</published>
    <updated>2019-04-04T08:51:45.559Z</updated>
    
    <content type="html"><![CDATA[<p>本书用通俗的语言介绍财务报表，一本零财务基础的人也可以看懂的扫盲书。 <a id="more"></a></p><div><p><img src="/images/reading-notes-1000.jpg" alt="报表立面图"></p></div><h2 id="损益表---核心是长期稳定获利能力">损益表 - 核心是长期稳定获利能力</h2><h4 id="计算损益平衡点用于决策时速算利润">计算损益平衡点，用于决策时速算利润</h4><p>推算平衡点时，首先要将成本与费用分成<strong>固定</strong>和<strong>变动</strong>两类，固定类是指无论产品买卖数量多少都不会变化的费用，例如，水电费、房租、薪金等。 变动类是指随销量增减而比变化的费用，例如，直接材料费，直接人工费，产品进货成本等，平衡点意味着总收入(TR)等于总支出(TC)的临界状态，即盈亏分界线。</p><p><span class="math display">\[总收入(TR) = P(价格) \times Q(数量)\]</span></p><p><span class="math display">\[总成本(TC) = 固定成本 + 变动成本\]</span></p><p><span class="math display">\[损益平衡点收益 = \frac {固定成本} {1 - \frac {变动成本} {前一年总收入(P \times Q)}}\]</span></p><h4 id="损益表科目">损益表科目</h4><ul><li>营业收入不能只看金额大小，而要看营收质量，要细分收入来源，通常有三大类：<ul><li>依客户区分， 使用80/20法则，分析贡献率80%的客户的稳定性。</li><li>依产品线区分，确定哪个产品贡献大。</li><li>依区域区分，创造营收的客户或区域的集中度，通常集中度意味着风向高。</li></ul></li><li>折旧费用: 记录有形资产贬值幅度</li><li>分期摊销费用: 记录无形资产贬值幅度</li><li>净利润分配方式有如下5种，选择现金或还款是上策<ul><li>现金: 货币资金，应收帐款</li><li>投资：存货、预付费用、固定资产（厂房设备）</li><li>并购：土地、无形资产</li><li>还款：负债科目</li><li>分红：权益科目</li></ul></li></ul><h2 id="资产负债表-静态数据">资产负债表 (静态数据)</h2><p><span class="math display">\[资产(Asset) = 负债(Debt) + 股东权益(Equity)\]</span></p><h4 id="资产科目">资产科目</h4><ul><li>货币资金（90天内到期的金融资产）</li><li>应收帐款</li><li>存货</li><li>预付费用</li><li>固定资产</li><li>无形资产</li></ul><h4 id="负债科目">负债科目</h4><ul><li>应付帐款/税款</li><li>长期贷款/负债</li></ul><h4 id="权益科目">权益科目</h4><ul><li>实收资本</li><li>资本公积，来源包括：<ul><li>股本溢价</li><li>资产重估价值</li><li>处理固定资产收益</li><li>企业合并收益</li><li>捐赠</li></ul></li><li>盈余公积</li></ul><h2 id="现金流量表">现金流量表</h2><ul><li>运营活动现金流量（来自损益表），考虑自由现金流量(FCF)</li></ul><p><span class="math display">\[FCF=营运活动现金流量 - 维持生存的基本资本支出\]</span></p><ul><li>投资活动现金流量（来自资产负债表左侧资产类科目期末减期初）</li><li>融资活动现金流量（来自资产负债表右侧科目期末减期初）</li></ul><h2 id="总结">总结</h2><div><p><img src="/images/reading-notes-1001.jpg" alt="生意周期"></p></div><h4 id="会计师意见是-无保留意见">会计师意见是 "无保留意见"</h4><h4 id="企业经营最好的是-快收慢付">企业经营最好的是 "快收慢付"</h4><h4 id="总资产周转率翻桌率越大越好">总资产周转率（翻桌率），越大越好</h4><p><span class="math display">\[总资产周转率 = \frac {销售收入} {总资产}\]</span></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总资产周转率 &lt; 1， 通常是资本密集（烧钱）或奢侈品行业</span><br><span class="line">总资产周转率 &gt; 1， 整体经营很好</span><br><span class="line">总资产周转率 &gt; 2， 流通业或经营效率超高的公司</span><br></pre></td></tr></table></figure><h4 id="固定资产周转率翻桌率越大越好-可选">固定资产周转率（翻桌率），越大越好 （可选）</h4><p><span class="math display">\[固定资产周转率 = \frac {销售收入} {固定资产}\]</span></p><h4 id="应收帐款周转率翻桌率越大越好">应收帐款周转率（翻桌率），越大越好</h4><p>注意：如果应收帐款收现天数逐年增加，但现金占总资产比率减少，且应收帐款占总资产比率增加，考虑企业在作假？</p><p><span class="math display">\[应收帐款周转率 = \frac {销售收入} {应收帐款}\]</span></p><p><span class="math display">\[应收帐款收现天数（收回帐款天数） = \frac {360} {应收帐款周转率}\]</span></p><h4 id="存货周转率翻桌率越大越好">存货周转率（翻桌率），越大越好</h4><p><span class="math display">\[存货周转率 = \frac {销售成本} { \frac {期初存货 + 期末存货} {2} }\]</span></p><p><span class="math display">\[商品平均售出天数 = \frac {360} {存货周转率}\]</span></p><h4 id="应付帐款周转率">应付帐款周转率</h4><p><span class="math display">\[应付帐款周转率 = \frac {销售成本} {应付帐款}\]</span></p><h4 id="净利率">净利率</h4><p><span class="math display">\[净利率 = \frac {净收益} {销售收入}\]</span></p><h4 id="总资产报酬率roa">总资产报酬率(ROA)</h4><p><span class="math display">\[总资产报酬率(ROA) = \frac {净收益} {总资产} = (\frac {净收益} {销售收入}) \times (\frac {销售收入} {总资产}) = 净利率 \times 总资产周转率\]</span></p><h4 id="现金分析">现金分析</h4><ul><li>营业活动现金流量 &gt; 0</li><li>营业活动现金流量 &gt; 净利</li><li>营业活动现金流量 &gt; 流动负债</li><li>营业活动现金流量同损益表的净利变化趋势相同</li></ul><h4 id="现金为王护城河">现金为王（护城河）</h4><ul><li>货币资金（现金等价物）占总资产比率，至少超过10%, 最好大于25%</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本书用通俗的语言介绍财务报表，一本零财务基础的人也可以看懂的扫盲书。
    
    </summary>
    
      <category term="books" scheme="http://lixueon.com/categories/books/"/>
    
    
      <category term="finance" scheme="http://lixueon.com/tags/finance/"/>
    
  </entry>
  
  <entry>
    <title>Notepad++常用插件</title>
    <link href="http://lixueon.com/2018/04/22/notepadplusplus-plugin/"/>
    <id>http://lixueon.com/2018/04/22/notepadplusplus-plugin/</id>
    <published>2018-04-22T09:48:36.385Z</published>
    <updated>2018-04-22T09:48:36.386Z</updated>
    
    <content type="html"><![CDATA[<p>本文整理 Notepad++ 相关技巧 <a id="more"></a></p><h1 id="插件-markdownviewerplusplus">插件 <a href="https://github.com/nea/MarkdownViewerPlusPlus" target="_blank" rel="noopener">MarkdownViewerPlusPlus</a></h1><p>Download a release version and copy the included MarkdownViewerPlusPlus.dll to the plugins sub-folder at your Notepad++ installation directory. The plugin adds a small Markdown icon Markdown icon to the toolbar to toggle the viewer as dockable panel.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文整理 Notepad++ 相关技巧
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用GitHub和Hexo写博客</title>
    <link href="http://lixueon.com/2018/04/22/github-hexo-blog/"/>
    <id>http://lixueon.com/2018/04/22/github-hexo-blog/</id>
    <published>2018-04-22T09:48:36.384Z</published>
    <updated>2018-04-22T09:48:36.385Z</updated>
    
    <content type="html"><![CDATA[<p>本文使用GitHub Pages和Hexo创建博客。 <a id="more"></a></p><h3 id="安装node.js">安装<a href="http://nodejs.org" target="_blank" rel="noopener">Node.js</a></h3><p>安装64-bit版本，保持默认设置即可，使用命令<code>node -v</code>或<code>npm -v</code>检查安装是否正确。</p><h3 id="安装git">安装<a href="http://git-scm.com" target="_blank" rel="noopener">Git</a></h3><p>安装64-bit版本，保持默认设置即可，使用命令<code>git --version</code>检查安装是否正确。</p><h3 id="配置github">配置<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a></h3><ul><li>注册账号"yourname"</li><li>创建仓库"yourname.github.io"</li></ul><h3 id="配置ssh-keys">配置SSH keys</h3><ul><li><p>打开Git Bash, 生成SSH KEY <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh</span><br><span class="line">$ ssh-keygen -t rsa -C <span class="string">"yourname@hotmail.com"</span></span><br></pre></td></tr></table></figure></p></li><li><p>打开文件id_rsa.pub，复制文件内容</p></li><li><p>登陆GitHub，点击右上角的 Account Settings---&gt;SSH Public keys ---&gt; add another public keys</p></li><li><p>把你本地生成的密钥复制到里面(key文本框中)， 点击<code>add key</code></p></li><li><p>测试配置是否成功 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@GitHub.com</span><br></pre></td></tr></table></figure></p></li></ul><h3 id="域名godaddy">域名<a href="https://sg.godaddy.com/zh/" target="_blank" rel="noopener">GoDaddy</a></h3><ul><li>购买域名"yoursite.com"</li><li>点击你的账户，管理我的域名</li><li>将GoDaddy的Nameservers更改成 f1g1ns1.dnspod.net 和 f1g1ns2.dnspod.net</li></ul><h3 id="配置dnspod">配置<a href="https://www.dnspod.cn/" target="_blank" rel="noopener">DNSpod</a></h3><ul><li>注册</li><li>添加配置 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*   A     192.30.252.153</span><br><span class="line">@   A     192.30.252.154</span><br><span class="line">www CNAME yourname.github.io</span><br></pre></td></tr></table></figure></li></ul><h3 id="生成和发布-hexo">生成和发布 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></h3><h4 id="安装">安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> d:/hexo</span><br><span class="line">$ npm install hexo-cli -g</span><br><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line">$ hexo g <span class="comment"># 或者hexo generate</span></span><br><span class="line">$ hexo s <span class="comment"># 或者hexo server，可以在http://localhost:4000/ 查看</span></span><br></pre></td></tr></table></figure><h4 id="常用命令">常用命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate (hexo g) #生成静态文件，会在当前目录下生成一个新的叫做public的文件夹</span><br><span class="line">hexo server (hexo s) #启动本地web服务，用于博客的预览</span><br><span class="line">hexo deploy (hexo d) #部署播客到远端(比如github, heroku等平台)</span><br><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br></pre></td></tr></table></figure><h4 id="常用简写">常用简写</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo n == hexo new</span><br><span class="line">$ hexo g == hexo generate</span><br><span class="line">$ hexo s == hexo server</span><br><span class="line">$ hexo d == hexo deploy</span><br></pre></td></tr></table></figure><h4 id="部署">部署</h4><p>部署到github，需要在配置文件_config.yml中作如下修改： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url: http://yoursite.com</span><br><span class="line">...</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:yourname/yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><p>然后在命令行中执行 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></p><p>测试yml可以使用<a href="http://www.yamllint.com/" target="_blank" rel="noopener">YAML Lint</a></p><h4 id="使用git命令行部署">使用git命令行部署</h4><p>将我们之前创建的repo克隆到本地，新建一个目录叫做.deploy用于存放克隆的代码 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> d:/hexo/blog</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/yourname/yourname.github.io.git .deploy/yourname.github.io</span><br></pre></td></tr></table></figure></p><p>创建一个deploy脚本文件 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">cp -R public/* .deploy/yourname.github.io</span><br><span class="line">cd .deploy/yourname.github.io</span><br><span class="line">git add .</span><br><span class="line">git commit -m “update”</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p><h3 id="添加域名的cname文件">添加域名的CNAME文件</h3><p>在source目录下创建CNAME文件，文件内容是 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yoursite.com</span><br></pre></td></tr></table></figure></p><h3 id="更换hexo主题">更换Hexo主题</h3><p>首先下载主题freemind： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ git clone https://github.com/wzpan/hexo-theme-freemind.git themes/freemind</span><br></pre></td></tr></table></figure></p><p>然后修改Hexo目录下的_config.yml配置文件中的theme属性，将其设置为freemind <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: freemind</span><br></pre></td></tr></table></figure></p><p>最后更新主题 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd themes/freemind</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure></p><h3 id="支持latex">支持LaTex</h3><ul><li>安装<a href="http://www.pandoc.org/installing.html" target="_blank" rel="noopener">Pandoc</a></li><li>卸载hexo默认的marked, 然后安装pandoc <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-renderer-mathjax --save</span><br><span class="line">$ npm uninstall hexo-renderer-marked --save</span><br><span class="line">$ npm install hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文使用GitHub Pages和Hexo创建博客。
    
    </summary>
    
    
  </entry>
  
</feed>
