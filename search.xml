<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基金005644]]></title>
    <url>%2F2019%2F02%2F27%2FFund-005644-2018%2F</url>
    <content type="text"><![CDATA[本文研究基金 “广发沪港深龙头混合 (005644)” 在2018年净值减少的原因。 2018年初，看着基金名字”沪港深龙头“就买入了基金005644，然后就悲剧了，基金从2018年 3月21日开始交易后，净值一路走低，截至到四季度时亏15%，它成为2018年最失败的投资。 此此基金可同时交易深沪港的股票，研究后却发现此基金只交易港股，并未买卖深沪的股票， 所以深沪股市大涨，此基金却依旧巨亏，尤其麻烦的是基金经理貌似缺乏投资港股的经验， 一味追涨杀跌，搞不懂基金经理为啥不是价值投资？这操作同散户没任何区别，咋盈利？ 根据基金的持仓信息，制作下表模拟基金的行为： 其中: 季度均价 = (当季度内最高收盘价 + 当季度内最低收盘价) / 2 无法通过持仓而准确知道买入和卖出股票的价格和数量，但它可充分反映投资过程，由于 二季度末时股票资金总额约250亿元，截至到2018年末亏损总额为约36.4亿元，因此： 盈余率 = 1 - （36.4/250） = 0.856 这个结果匹配2018年末的基金净值0.8439，所以净值减少的原因就是炒股亏了。 总之，失败不总是坏事，至少得到如下经验： 买基金前，必须要先仔细看说明，关注基金经理过往战绩，不要找小白，专业的事情 要交给专业并优秀的人去做，找那些赚佣金的同时兼顾客户利益的基金经理。 购买基金时，必须分批投入，风险至上，及时止损。 购买基金后，不要幻想坐等收钱，必须定时跟踪基金状态，买龙头股也不一定会盈利， 即使专业的人去操作也不一定。 股票投资要严守纪律，严格止损。]]></content>
      <categories>
        <category>stocks</category>
      </categories>
      <tags>
        <tag>finance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单件 (SINGLETON)]]></title>
    <url>%2F2018%2F08%2F29%2FDesignPattern-Singleton%2F</url>
    <content type="text"><![CDATA[单件模式是一个简单的模式，要正确的实现此模式仍需要考虑很多细节，由于单件模式不符合对象 的单一职责原则，论坛上对是否应该使用单件模式的争议很多，因单件模式适用的场景很少，在 程序设计中又极容易被滥用，如果没有急迫并且有意义的需要时，应该避免使用这个模式。 目的 确保一个类只有一个实例 (Ensure a class only has one instance) 提供一个全局访问点 (Provide a global point of access to it) 动机 有一些对象可能只需要一个，例如：线程池(thread pool), 缓存(cache), 注册表对象，日志 对象，打印机驱动程序对象，窗口管理器等。 如何可以保证一个类只有一个实例？全局变量可以被访问，但不能防止被实例化多次。一个办法是 让类自身保存它的唯一实例，这个类提供一个访问该实例的方法，即单件模式。 单件模式提供了全局访问点，同全局变量一样方便，但避免了全局变量的缺点。比如，将对象赋值 给全局变量，通常在程序开始时创建对象（JVM是用到时创建），如果此对象非常耗费资源，而程序 中没有使用到它，则形成浪费。通过使用单件，可以在需要时创建这个对象。 参与者 (Participants) Singleton 定义Instance方法，允许客户访问它的唯一实例。 负责创建它自己的唯一实例 协作 (Collaborations) 客户只能通过Singleton的Instance方法访问Singleton的实例。 效果 好处 跨平台：使用合适的中间件（例如：RMI），可以把单件模式扩展为跨多个JVM或多个计算机工作。 适用于任何类：将类的构造函数变为私有的，然后增加相应的静态函数和变量，就可实现单件。 可以透过派生创建：给定一个类，可以创建它的一个单件子类 延迟求值（Lazy evaluation）：如果单件从未使用，就绝不创建它。 代价 摧毁方法未定义：没有好的方法去destroy一个单件或解除其职责。此问题在C++中尤其严重。 不能继承：从单件类继承的子类并不是单件，需要添加静态函数和变量从而变成单件。 效率问题：当未使用静态函数的静态变量，每次调用Instance方法都会执行一个if语句。 不透明性：单件的使用者知道在调用单件模式，因为需要调用Instance方法。 实现 C++的相关问题 是否支持延迟求值可依照具体情况而定 考虑默认拷贝构造函数 私有化构造函数，确保只通过Instance方法得到实例 线程安全 由于C++ 2011已经支持线程安全，参考下面的实例代码。 对于C++ 2003及之前版本，线程安全可采用如下方式： 在Instance方法中增加同步锁 在Instance方法中使用Double-Checked Locking 使用类的静态变量 Java的相关问题 Java中实现单件模式需要私有的构造器，一个静态方法，一个静态变量 确定性能和资源上的限制，然后小心选择适当的方案，以解决多线程问题（最好认定所有程序 都是多线程的） 只有Java 5或以上版本,才支持双重检查锁 (Double-Checked Locking) 小心，如果你使用多个类加载器，可能导致单件失效而产生多个实例 如果使用JVM 1.2或之前版本，你必须建立单件注册表，以免垃圾回收期将单件回收 代码 C++ 2003 单线程版本 class Singleton&#123;public: static Singleton&amp; Instance() &#123; static Singleton instance; return instance; &#125;private: Singleton() &#123;&#125; Singleton(Singleton const&amp;); void operator=(Singleton const&amp;);&#125;; C++ 2011 线程安全版本 class Singleton&#123;public: static Singleton&amp; Instance() &#123; static Singleton instance; return instance; &#125; Singleton(Singleton const&amp;) = delete; void operator=(Singleton const&amp;) = delete;private: Singleton() &#123;&#125;&#125;; Java静态实例化 public class Singleton&#123; private static Singleton _instance = new Singleton(); private Singleton() &#123;&#125; public static Singleton Instance() &#123; return _instance; &#125;&#125; Java延迟实例化 - 单线程 public class Singleton&#123; private static Singleton _instance; private Singleton() &#123;&#125; public static Singleton Instance() &#123; if (_instance == null) _instance = new Singleton(); return _instance; &#125;&#125; Java延迟实例化 - 多线程 多线程同步的问题: 增加synchronized同步后，不会有两个线程同时进入方法，同步会令执行效率下降100倍。 只有第一次执行此方法时需要同步，对象创建后，同步成为一个影响性能的累赘。 如果资源创建和运行方面的负担不繁重，可考虑“静态实例化”来替代同步。 public class Singleton&#123; private static Singleton _instance; private Singleton() &#123;&#125; public static synchronized Singleton Instance() &#123; if (_instance == null) _instance = new Singleton(); return _instance; &#125;&#125; Java双重检查锁(Double-Checked Locking) - 多线程 《设计模式精解》指出：Java中双重检查锁无效果，理由如下： Java内存管理指出，只在两个线程在同一个对象上进行同步时，它才会保证一个线程 B 能够 看到另一个线程 A 的改变，从而使得线程 A 得 synchronized 块对线程 B 变为原子，即 要么什么都不做，要么完全改好。 Java并不是一种按照源代码顺序执行的语言。Java对编译器和虚拟机的要求时满足 as-if-serial: 也就是只要它能够达到和严格顺序执行一样的效果，指令执行的顺序可以随便安排。 《Head First设计模式》指出：Java 5或之后版本可通过 volatile 支持双重检查锁 public class Singleton&#123; private volatile static Singleton _instance; private Singleton() &#123;&#125; public static Singleton Instance() &#123; if （_instance == null) &#123; synchronized (Singleton.class) &#123; if （_instance == null) _instance = new Singleton(); &#125; &#125; return _instance; &#125;&#125; Java接口应用示例 public interface IDatabase&#123; void Write();&#125;public class UserDatabase implements IDatabase&#123; private static UserDatabase _instance = new UserDatabase(); private UserDatabase() &#123;&#125; public static UserDatabase Instance() &#123; return _instance; &#125; public void Write() &#123; // Some Implementation &#125;&#125; C++注册表应用示例 Singleton.h class IDatabase&#123;public: virtual void Write() &#123;&#125;&#125;;class Singleton : public IDatabase&#123;protected: Singleton() &#123;&#125;public: Singleton(Singleton const&amp;) = delete; void operator= (Singleton const&amp;) = delete; static Singleton* Instance(); static void Register(const char* name, Singleton* instance); static Singleton* Lookup(const char* name);private: static Singleton* _instance;&#125;; Singleton.cpp static std::map&lt;std::string, Singleton*&gt; _registry;Singleton* Singleton::_instance;Singleton* Singleton::Instance()&#123; if (!_instance) &#123; const char* name = getenv("SINGLETON"); _instance = Lookup(name); &#125; return _instance;&#125;void Singleton::Register(const char* name, Singleton* instance)&#123; _registry.insert(std::make_pair(name, instance));&#125;Singleton* Singleton::Lookup(const char* name)&#123; return _registry[name];&#125; MySingleton.h class MySingleton : public Singleton&#123;public: MySingleton() &#123; Singleton::Register("MySingleton", this); &#125; virtual void Write() &#123; // Some Implementation &#125;&#125;; client.cpp static MySingleton theSingleton;int main()&#123; _putenv("SINGLETON=MySingleton"); Singleton::Instance()-&gt;Write(); return 0;&#125; C++工厂应用示例 class MazeFactory&#123;public: static MazeFactory* Instance();protected: MazeFactory() &#123;&#125;private: static MazeFactory* _instance;&#125;;class BombedMazeFactory : public MazeFactory&#123;&#125;;class EnchantedMazeFactory : public MazeFactory&#123;&#125;;MazeFactory* MazeFactory::Instance()&#123; if (_instance == 0) &#123; const char* mazeStyle = getenv("MAZESTYLE"); if (strcmp(mazeStyle, "bombed") == 0) _instance = new BombedMazeFactory(); else if (strcmp(mazeStyle, "enchanted") == 0) _instance = new EnchantedMazeFactory(); // ... else _instance = new MazeFactory(); &#125; return _instance;&#125; 相关模式 (Related Patterns) 如下模式或可用Singleton模式实现： Abstract Factory Builder Prototype 参考 (Reference) 设计模式：可复用面向对象软件的基础 设计模式精解 敏捷软件开发 Head First 设计模式 Design Patterns]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 代码规范]]></title>
    <url>%2F2018%2F07%2F04%2FPythonStyleGuide%2F</url>
    <content type="text"><![CDATA[本文有关于Python的编码规范，以确立统一代码风格和样式，方便阅读和维护。 代码格式 缩进 统一使用4个空格进行缩进 行宽 每行代码尽量不超过 80 个字符(在特殊情况下可以略微超过 80 ，但最长不得超过 120) 理由： - 这在查看 side-by-side 的 diff 时很有帮助 - 方便在控制台下查看代码 - 太长可能是设计有缺陷 引号 简单说，自然语言使用双引号，机器标示使用单引号，因此代码里多数应该使用 单引号 - 自然语言 使用双引号 “…” 例如错误信息；很多情况还是 unicode，使用u“你好世界” - 机器标识 使用单引号 ‘…’ 例如 dict 里的 key - 正则表达式 使用原生的双引号 r“…” 文档字符串 (docstring) 使用三个双引号 “”“……”“” 空行 模块级函数和类定义之间空两行； 类成员函数之间空一行； class A: def __init__(self): pass def hello(self): passdef main(): pass 可以使用多个空行分隔多组相关的函数 函数中可以使用空行分隔出逻辑相关的代码 编码 如无特殊情况, 文件一律使用 UTF-8 编码 如无特殊情况, 文件头部必须加入#--coding:utf-8--标识 import语句 import 语句应该分行书写 # 正确的写法import osimport sys# 不推荐的写法import sys,os# 正确的写法from subprocess import Popen, PIPE import语句应该使用 absolute import # 正确的写法from foo.bar import Bar# 不推荐的写法from ..bar import Bar import语句应该放在文件头部，置于模块说明及docstring之后，于全局变量之前； import语句应该按照顺序排列，每组之间用一个空行分隔 import osimport sysimport msgpackimport zmqimport foo 导入其他模块的类定义时，可以使用相对导入 from myclass import MyClass 如果发生命名冲突，则可使用命名空间 import barimport foo.barbar.Bar()foo.bar.Bar() 空格 在二元运算符两边各空一格[=,-,+=,==,&gt;,in,is not, and]: # 正确的写法i = i + 1submitted += 1x = x * 2 - 1hypot2 = x * x + y * yc = (a + b) * (a - b)# 不推荐的写法i=i+1submitted +=1x = x*2 - 1hypot2 = x*x + y*yc = (a+b) * (a-b) 函数的参数列表中，,之后要有空格 # 正确的写法def complex(real, imag): pass# 不推荐的写法def complex(real,imag): pass 函数的参数列表中，默认值等号两边不要添加空格 # 正确的写法def complex(real, imag=0.0): pass# 不推荐的写法def complex(real, imag = 0.0): pass 左括号之后，右括号之前不要加多余的空格 # 正确的写法spam(ham[1], &#123;eggs: 2&#125;)# 不推荐的写法spam( ham[1], &#123; eggs : 2 &#125; ) 字典对象的左括号之前不要多余的空格 # 正确的写法dict[&apos;key&apos;] = list[index]# 不推荐的写法dict [&apos;key&apos;] = list [index] 不要为对齐赋值语句而使用的额外空格 # 正确的写法x = 1y = 2long_variable = 3# 不推荐的写法x = 1y = 2long_variable = 3 换行 Python 支持括号内的换行。这时有两种情况。 第二行缩进到括号的起始处 foo = long_function_name(var_one, var_two, var_three, var_four) 第二行缩进 4 个空格，适用于起始括号就换行的情形 def long_function_name( var_one, var_two, var_three, var_four): print(var_one) 使用反斜杠，二元运算符+ .等应出现在行末；长字符串也可以用此法换行 session.query(MyTable).\ filter_by(id=1).\ one()print &apos;Hello, &apos;\ &apos;%s %s!&apos; %\ (&apos;Harry&apos;, &apos;Potter&apos;) 禁止复合语句，即一行中包含多个语句： # 正确的写法do_first()do_second()do_third()# 不推荐的写法do_first();do_second();do_third(); if/for/while一定要换行： # 正确的写法if foo == &apos;blah&apos;: do_blah_thing()# 不推荐的写法if foo == &apos;blah&apos;: do_blash_thing() docstring docstring 的规范中最其本的两点： 所有的公共模块、函数、类、方法，都应该写 docstring 。私有方法不一定需要，但应该在 def 后提供一个块注释来说明。 docstring 的结束“”“应该独占一行，除非此 docstring 只有一行。 &quot;&quot;&quot;Return a foobarOptional plotz says to frobnicate the bizbaz first.&quot;&quot;&quot;&quot;&quot;&quot;Oneline docstring&quot;&quot;&quot; 注释 块注释 “#”号后空一格，段落件用空行分开（同样需要“#”号） # 块注释# 块注释## 块注释# 块注释 行注释 至少使用两个空格和语句分开，注意不要使用无意义的注释 # 正确的写法x = x + 1 # 边框加粗一个像素# 不推荐的写法(无意义的注释)x = x + 1 # x加1 建议 在代码的关键部分(或比较复杂的地方), 能写注释的要尽量写注释 比较重要的注释段, 使用多个等号隔开, 可以更加醒目, 突出重要性 app = create_app(name, options)# =====================================# 请勿在此处添加 get post等app路由行为 !!!# =====================================if __name__ == &apos;__main__&apos;: app.run() 文档注释（Docstring） 作为文档的Docstring一般出现在模块头部、函数和类的头部，这样在python中可以通过对象的__doc__对象获取文档. 编辑器和IDE也可以根据Docstring给出自动提示. 文档注释以 “”&quot; 开头和结尾, 首行不换行, 如多行末行必换行. 以下是Google的docstring风格示例 # -*- coding: utf-8 -*-&quot;&quot;&quot;Example docstrings.This module demonstrates documentation as specified by the `Google PythonStyle Guide`_. Docstrings may extend over multiple lines. Sections are createdwith a section header and a colon followed by a block of indented text.Example: Examples can be given using either the ``Example`` or ``Examples`` sections. Sections support any reStructuredText formatting, including literal blocks:: $ python example_google.pySection breaks are created by resuming unindented text. Section breaksare also implicitly created anytime a new section starts.&quot;&quot;&quot; 不要在文档注释复制函数定义原型, 而是具体描述其具体内容, 解释具体参数和返回值等 # 正确的写法def function(a, b): &quot;&quot;&quot;计算并返回a到b范围内数据的平均值&quot;&quot;&quot; ... ...# 不推荐的写法(不要写函数原型等废话)def function(a, b): &quot;&quot;&quot;function(a, b) -&gt; list&quot;&quot;&quot; ... ... 对函数参数、返回值等的说明采用numpy标准, 如下所示 def func(arg1, arg2): &quot;&quot;&quot;在这里写函数的一句话总结(如: 计算平均值). 这里是具体描述. 参数 ---------- arg1 : int arg1的具体描述 arg2 : int arg2的具体描述 返回值 ------- int 返回值的具体描述 参看 -------- otherfunc : 其它关联函数等... 示例 -------- 示例使用doctest格式, 在`&gt;&gt;&gt;`后的代码可以被文档测试工具作为测试用例自动运行 &gt;&gt;&gt; a=[1,2,3] &gt;&gt;&gt; print [x + 3 for x in a] [4, 5, 6] &quot;&quot;&quot; 文档注释不限于中英文, 但不要中英文混用 文档注释不是越长越好, 通常一两句话能把情况说清楚即可 模块、公有类、公有方法, 能写文档注释的, 应该尽量写文档注释 命名规范 模块 模块尽量使用小写命名，首字母保持小写，尽量不要用下划线 # 正确的模块名import decoderimport html_parser# 不推荐的模块名import Decoder 类名 类名使用驼峰(CamelCase)命名风格，首字母大写，私有类可用一个下划线开头 class Farm(): passclass AnimalFarm(Farm): passclass _PrivateFarm(Farm): pass 将相关的类和顶级函数放在同一个模块里. 不像Java, 没必要限制一个类一个模块. 函数 函数名一律小写，如有多个单词，用下划线隔开 def run(): passdef run_with_env(): pass 私有函数在函数前加一个下划线_ class Person(): def _private_func(): pass 变量名 变量名尽量小写, 如有多个单词，用下划线隔开 if __name__ == &apos;__main__&apos;: count = 0 school_name = &apos;&apos; 常量 常量采用全大写，如有多个单词，使用下划线隔开 MAX_CLIENT = 100MAX_CONNECTION = 1000CONNECTION_TIMEOUT = 600]]></content>
      <categories>
        <category>document</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记 - 用生活常识就能看懂财务报表]]></title>
    <url>%2F2018%2F04%2F22%2F%E7%94%A8%E7%94%9F%E6%B4%BB%E5%B8%B8%E8%AF%86%E5%B0%B1%E8%83%BD%E7%9C%8B%E6%87%82%E8%B4%A2%E5%8A%A1%E6%8A%A5%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[本书用通俗的语言介绍财务报表，一本零财务基础的人也可以看懂的扫盲书。 损益表 - 核心是长期稳定获利能力 计算损益平衡点，用于决策时速算利润 推算平衡点时，首先要将成本与费用分成固定和变动两类，固定类是指无论产品买卖数量多少都不会变化的费用，例如，水电费、房租、薪金等。 变动类是指随销量增减而比变化的费用，例如，直接材料费，直接人工费，产品进货成本等，平衡点意味着总收入(TR)等于总支出(TC)的临界状态，即盈亏分界线。 \[总收入(TR) = P(价格) \times Q(数量)\] \[总成本(TC) = 固定成本 + 变动成本\] \[损益平衡点收益 = \frac {固定成本} {1 - \frac {变动成本} {前一年总收入(P \times Q)}}\] 损益表科目 营业收入不能只看金额大小，而要看营收质量，要细分收入来源，通常有三大类： 依客户区分， 使用80/20法则，分析贡献率80%的客户的稳定性。 依产品线区分，确定哪个产品贡献大。 依区域区分，创造营收的客户或区域的集中度，通常集中度意味着风向高。 折旧费用: 记录有形资产贬值幅度 分期摊销费用: 记录无形资产贬值幅度 净利润分配方式有如下5种，选择现金或还款是上策 现金: 货币资金，应收帐款 投资：存货、预付费用、固定资产（厂房设备） 并购：土地、无形资产 还款：负债科目 分红：权益科目 资产负债表 (静态数据) \[资产(Asset) = 负债(Debt) + 股东权益(Equity)\] 资产科目 货币资金（90天内到期的金融资产） 应收帐款 存货 预付费用 固定资产 无形资产 负债科目 应付帐款/税款 长期贷款/负债 权益科目 实收资本 资本公积，来源包括： 股本溢价 资产重估价值 处理固定资产收益 企业合并收益 捐赠 盈余公积 现金流量表 运营活动现金流量（来自损益表），考虑自由现金流量(FCF) \[FCF=营运活动现金流量 - 维持生存的基本资本支出\] 投资活动现金流量（来自资产负债表左侧资产类科目期末减期初） 融资活动现金流量（来自资产负债表右侧科目期末减期初） 总结 会计师意见是 “无保留意见” 企业经营最好的是 “快收慢付” 总资产周转率（翻桌率），越大越好 \[总资产周转率 = \frac {销售收入} {总资产}\] 总资产周转率 &lt; 1， 通常是资本密集（烧钱）或奢侈品行业总资产周转率 &gt; 1， 整体经营很好总资产周转率 &gt; 2， 流通业或经营效率超高的公司 固定资产周转率（翻桌率），越大越好 （可选） \[固定资产周转率 = \frac {销售收入} {固定资产}\] 应收帐款周转率（翻桌率），越大越好 注意：如果应收帐款收现天数逐年增加，但现金占总资产比率减少，且应收帐款占总资产比率增加，考虑企业在作假？ \[应收帐款周转率 = \frac {销售收入} {应收帐款}\] \[应收帐款收现天数（收回帐款天数） = \frac {360} {应收帐款周转率}\] 存货周转率（翻桌率），越大越好 \[存货周转率 = \frac {销售成本} { \frac {期初存货 + 期末存货} {2} }\] \[商品平均售出天数 = \frac {360} {存货周转率}\] 应付帐款周转率 \[应付帐款周转率 = \frac {销售成本} {应付帐款}\] 净利率 \[净利率 = \frac {净收益} {销售收入}\] 总资产报酬率(ROA) \[总资产报酬率(ROA) = \frac {净收益} {总资产} = (\frac {净收益} {销售收入}) \times (\frac {销售收入} {总资产}) = 净利率 \times 总资产周转率\] 现金分析 营业活动现金流量 &gt; 0 营业活动现金流量 &gt; 净利 营业活动现金流量 &gt; 流动负债 营业活动现金流量同损益表的净利变化趋势相同 现金为王（护城河） 货币资金（现金等价物）占总资产比率，至少超过10%, 最好大于25%]]></content>
      <categories>
        <category>books</category>
      </categories>
      <tags>
        <tag>finance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Notepad++常用插件]]></title>
    <url>%2F2018%2F04%2F22%2Fnotepadplusplus-plugin%2F</url>
    <content type="text"><![CDATA[本文整理 Notepad++ 相关技巧 插件 MarkdownViewerPlusPlus Download a release version and copy the included MarkdownViewerPlusPlus.dll to the plugins sub-folder at your Notepad++ installation directory. The plugin adds a small Markdown icon Markdown icon to the toolbar to toggle the viewer as dockable panel.]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用GitHub和Hexo写博客]]></title>
    <url>%2F2018%2F04%2F22%2Fgithub-hexo-blog%2F</url>
    <content type="text"><![CDATA[本文使用GitHub Pages和Hexo创建博客。 安装Node.js 安装64-bit版本，保持默认设置即可，使用命令node -v或npm -v检查安装是否正确。 安装Git 安装64-bit版本，保持默认设置即可，使用命令git --version检查安装是否正确。 配置GitHub 注册账号“yourname” 创建仓库“yourname.github.io” 配置SSH keys 打开Git Bash, 生成SSH KEY $ cd ~/.ssh$ ssh-keygen -t rsa -C "yourname@hotmail.com" 打开文件id_rsa.pub，复制文件内容 登陆GitHub，点击右上角的 Account Settings—&gt;SSH Public keys —&gt; add another public keys 把你本地生成的密钥复制到里面(key文本框中)， 点击add key 测试配置是否成功 $ ssh -T git@GitHub.com 域名GoDaddy 购买域名“yoursite.com” 点击你的账户，管理我的域名 将GoDaddy的Nameservers更改成 f1g1ns1.dnspod.net 和 f1g1ns2.dnspod.net 配置DNSpod 注册 添加配置 * A 192.30.252.153@ A 192.30.252.154www CNAME yourname.github.io 生成和发布 Hexo 安装 $ cd d:/hexo$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install$ npm install hexo-deployer-git --save$ hexo g # 或者hexo generate$ hexo s # 或者hexo server，可以在http://localhost:4000/ 查看 常用命令 hexo generate (hexo g) #生成静态文件，会在当前目录下生成一个新的叫做public的文件夹hexo server (hexo s) #启动本地web服务，用于博客的预览hexo deploy (hexo d) #部署播客到远端(比如github, heroku等平台)hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面 常用简写 $ hexo n == hexo new$ hexo g == hexo generate$ hexo s == hexo server$ hexo d == hexo deploy 部署 部署到github，需要在配置文件_config.yml中作如下修改： url: http://yoursite.com...deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 然后在命令行中执行 $ hexo d 测试yml可以使用YAML Lint 使用git命令行部署 将我们之前创建的repo克隆到本地，新建一个目录叫做.deploy用于存放克隆的代码 $ cd d:/hexo/blog$ git clone https://github.com/yourname/yourname.github.io.git .deploy/yourname.github.io 创建一个deploy脚本文件 hexo gcp -R public/* .deploy/yourname.github.iocd .deploy/yourname.github.iogit add .git commit -m “update”git push origin master 添加域名的CNAME文件 在source目录下创建CNAME文件，文件内容是 yoursite.com 更换Hexo主题 首先下载主题freemind： $ hexo clean$ git clone https://github.com/wzpan/hexo-theme-freemind.git themes/freemind 然后修改Hexo目录下的_config.yml配置文件中的theme属性，将其设置为freemind theme: freemind 最后更新主题 $ cd themes/freemind$ git pull 支持LaTex 安装Pandoc 卸载hexo默认的marked, 然后安装pandoc $ npm install hexo-renderer-mathjax --save$ npm uninstall hexo-renderer-marked --save$ npm install hexo-renderer-pandoc --save]]></content>
  </entry>
</search>
